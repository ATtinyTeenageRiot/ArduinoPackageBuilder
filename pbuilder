#!/bin/bash

cwd=$(pwd)
RELEASE_VERSION=()

STAGING_DIR="staging"
DEFAULT_CONFIG_FILE="config.conf"
RELEASES_DIR="releases"
RELEASES_BOARD_DIR="boards"
TEMPLATE_DIR="template"
TEMPLATE_PLATFORM_FILE="platform.json"
TEMPLATE_PACKAGE_FILE="package.json"

#REPO_LOCAL_DIR="staging/${REPO_SOURCE_LOCAL_DIR}"

#define the template.
function generate_platform_template() #version, url, checksum, size
{

local _version=${1}
local _url=${2}
local _sha=${3}
local _size=${4}
local _template=${4}

local _template_ext=".json"

if [ "default" = "${_template}" ] || [ "" = "${_template}" ]
then
_template="${TEMPLATE_PLATFORM_FILE}${_template_ext}"
else
_template+="${_template_ext}"
fi

local archiveFileName="${2}"; 
eval "cat <<EOF
$(<./${TEMPLATE_DIR}/${_template})
EOF
" 2> /dev/null
}

function generate_package_template() #platforms
{
local _platforms=${1}
local _template=${TEMPLATE_PACKAGE_FILE}
eval "cat <<EOF
$(<./${TEMPLATE_DIR}/${_template})
EOF
" 2> /dev/null
}

function git_update_repo()
{
	if [ -d "${STAGING_DIR}/${REPO_SOURCE_LOCAL_DIR}" ] #if directory exists
	then
		cd "${cwd}/${STAGING_DIR}/${REPO_SOURCE_LOCAL_DIR}"

		git fetch --all
		git pull --all

#		for b in `git branch -r | grep -v -- '->'`; 
#		do 
#			echo "${b}"
#			#git branch --track ${b##origin/} $b; 
#		done

	fi
	
	cd "${cwd}"
}

function update_release_repo() #repo url, dir, specific commit
{
	local _REPO_REMOTE_URL=${1}
	local _REPO_LOCAL_DIR=${2}
	local _COMMIT_HASH=${3}
	
	if [ -d "${_REPO_LOCAL_DIR}" ] #if directory exists
	then
		cd "${cwd}/${_REPO_LOCAL_DIR}"
		git reset --hard ${_COMMIT_HASH}
		git submodule update --init --recursive
		git submodule foreach --recursive git clean -d -f -f
	else
		git clone "${_REPO_REMOTE_URL}" "${_REPO_LOCAL_DIR}"
		cd "${_REPO_LOCAL_DIR}"
		git checkout ${_COMMIT_HASH}
		git submodule update --init --recursive
		git submodule foreach --recursive git clean -d -f -f
	fi
	
	cd "${cwd}"
}


function archive_release_repo() #repo dir, filename
{
	mkdir -p ${cwd}/${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}

	local _REPO_DIR=${1}
	local _ARCHIVE_FILE=${2}
	local _SOURCE_FILE=${3}

	cd ${cwd}/${_REPO_DIR}
	tar --exclude=".git" --exclude=".DS_Store" --exclude=".gitignore" --exclude=".gitmodules" -czf  ${cwd}/${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${_ARCHIVE_FILE}.tar.gz  ${_SOURCE_FILE}
	shasum -a 256 ${cwd}/${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${_ARCHIVE_FILE}.tar.gz  | cut -d ' ' -f 1 > ${cwd}/${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${_ARCHIVE_FILE}.sha.txt
	cd "${cwd}"
}


function check_release_archive_exists()
{
	local _FILE_NAME=${1}
	
	if [ -e "${cwd}/${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${_FILE_NAME}.tar.gz" ]
	then
		return 0 #true
	else
		return 1 #false
	fi
}


function make_packages()
{
	git_update_repo

	# get length of an array
	local tLen=${#RELEASE_VERSION[@]}
	 
	# use for loop read all
	for (( i=0; i<${tLen}; i++ ));
	do
  		IFS=', ' read -a array <<< "${RELEASE_VERSION[$i]}"
		local _RELEASE_VERSION=${array[0]}
		local _COMMIT_HASH=${array[1]}
		local _PLATFORM_TEMPLATE=${array[2]}
		

		if check_release_archive_exists ${RELEASE_PREFIX}${_RELEASE_VERSION}
		then
			echo "${_RELEASE_VERSION} exists, skip"
		else
			update_release_repo "${REPO_SOURCE_URL}" "${STAGING_DIR}/${REPO_SOURCE_LOCAL_DIR}" "${_COMMIT_HASH}"
			archive_release_repo "${STAGING_DIR}/${REPO_SOURCE_LOCAL_DIR}" "${RELEASE_PREFIX}${_RELEASE_VERSION}" "${BOARD_ARCH}"
		fi	

		local sha_result=`shasum -a 256 ${cwd}/${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${RELEASE_PREFIX}${_RELEASE_VERSION}.tar.gz | cut -d ' ' -f 1`
		platform_list+=`generate_platform_template ${_RELEASE_VERSION} ${RELEASE_FILE_URL}/${RELEASES_BOARD_DIR}/${RELEASE_PREFIX}${_RELEASE_VERSION}.tar.gz ${sha_result} ${_PLATFORM_TEMPLATE}`
		
		if [ $((i+1)) -ne $tLen ]
		then
			platform_list+=","
		fi
	done

	local json_package_output=`generate_package_template "${platform_list}"`
	echo "${json_package_output}" > "${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASE_INDEX_JSON_FILENAME}"
}


function add_new_release()
{
	echo -e "ADD_RELEASE_VERSION\t\t${1}\t${2}\t${3}\n" >> ${CONFIG_FILE}
}


function ADD_RELEASE_VERSION()
{
RELEASE_VERSION+=("${1}","${2}","${3}")
}


function list_release()
{
	local tLen=${#RELEASE_VERSION[@]}
	echo "------------------------------------------------------------------"			
	echo "Releases:"

	for (( i=0; i<${tLen}; i++ ));
	do
	IFS=', ' read -a array <<< "${RELEASE_VERSION[$i]}"
	local _RELEASE_VERSION=${array[0]}
	local _COMMIT_HASH=${array[1]}

	echo "- release version: ${_RELEASE_VERSION} commit: ${_COMMIT_HASH}"

	done

	echo "------------------------------------------------------------------"


}


function config_info()
{
cat<<EOF

------------------------------------------------------------------			
Package:

- BOARD_PACKAGE_NAME=${BOARD_PACKAGE_NAME}
- BOARD_PACKAGE_MAINTAINER=${BOARD_PACKAGE_MAINTAINER}
- BOARD_PACKAGE_WEB_URL=${BOARD_PACKAGE_WEB_URL}
- BOARD_PACKAGE_HELP_URL=${BOARD_PACKAGE_HELP_URL}
- BOARD_PACKAGE_MAINTAINER_EMAIL=${BOARD_PACKAGE_MAINTAINER_EMAIL}

- BOARD_NAME=${BOARD_NAME}
- BOARD_ARCH=${BOARD_ARCH}
- BOARD_CATEGORY=${BOARD_CATEGORY}
- BOARD_HELP_URL=${BOARD_HELP_URL}

Package url:
Copy paste into arduino package url list

- ${RELEASE_FILE_URL}/${RELEASE_INDEX_JSON_FILENAME}

------------------------------------------------------------------		

EOF
}

function usage()
{
echo "usage"
}



function check_config_exists()
{
	local _FILE_NAME=${1}
	
	if [ -e "${_FILE_NAME}" ]
	then
		echo "using config ${_FILE_NAME}"
		CONFIG_FILE="${_FILE_NAME}"
		source ${_FILE_NAME}
	else
		if [ -e "${DEFAULT_CONFIG_FILE}" ]
		then
			echo "using default ./${DEFAULT_CONFIG_FILE}"
			CONFIG_FILE="./${DEFAULT_CONFIG_FILE}"
			source "${CONFIG_FILE}"
		else
			echo "config not found, abort"
			exit 1
		fi
	fi
}

function git_init_release_pages()
{
	if [ -d "${RELEASES_DIR}/${RELEASE_REPO_DIR}" ] #if directory exists
	then
	echo "git init: directory ${RELEASES_DIR}/${RELEASE_REPO_DIR} already exist!"

	else

	cd ${RELEASES_DIR}
	
	git clone --depth 1 ${RELEASE_REPO_URL} ${RELEASE_REPO_DIR}
	cd ${RELEASE_REPO_DIR}
	git checkout --orphan ${RELEASE_REPO_BRANCH}

	cd ${cwd}

	fi
}

function git_push_release_pages()
{
	if [ -d "${RELEASES_DIR}/${RELEASE_REPO_DIR}" ] #if directory exists
	then
	
	cd ${RELEASES_DIR}/${RELEASE_REPO_DIR}

	git add .
	git commit -m "update release"
	git push origin ${RELEASE_REPO_BRANCH}

	cd ${cwd}

	else

	echo "git publish: directory ${RELEASES_DIR}/${RELEASE_REPO_DIR} is not exist!"
	
	fi
}


while [ "$1" != "" ]; do
    case $1 in
        -l | --list )   
			check_config_exists ${2} 
			list_release
			exit
        ;;
        -c | --config )
			check_config_exists ${2}
			make_packages
			exit
		;;
        -a | --add | add)
			check_config_exists ${2}
			config_info
			list_release

			echo ""			
			echo "Add new release"
			echo "Enter Version: "; read _version;
			echo "Enter Commit#: "; read _commit;
			add_new_release ${_version} ${_commit}
			exit		
        ;;
        -h | --help )
			usage
	        exit
        ;;
        -b | --build | build )
			check_config_exists ${2}
			make_packages
			exit
        ;;   
        publish )
			check_config_exists ${2}
			git_push_release_pages
	        exit
        ;;           
        init )
			check_config_exists ${2}
			git_init_release_pages
	        exit
        ;;  
        info )
			check_config_exists ${2} 
			config_info
			list_release
	        exit
        ;;            
        reset )
			check_config_exists ${2} 
			echo "hard reset local release repo"
			cd ${RELEASES_DIR}/${RELEASE_REPO_DIR}
			git reset --hard
	        exit
        ;;            
        clean )
			check_config_exists ${2} 
			echo "cleaning release folder and package json"
			echo "delete ${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${RELEASE_PREFIX}*"		
			rm -fr ${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASES_BOARD_DIR}/${RELEASE_PREFIX}*
			echo "delete ${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASE_INDEX_JSON_FILENAME}"		
			rm -fr ${RELEASES_DIR}/${RELEASE_REPO_DIR}/${RELEASE_INDEX_JSON_FILENAME}
	        exit
   #      ;;               
   #      * )
			# usage
	  #       exit 1
    esac
    shift
done


check_config_exists "./${DEFAULT_CONFIG_FILE}"
make_packages
